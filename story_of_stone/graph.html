<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta http-equiv="refresh" content="200">
<link rel="stylesheet/less" type="text/css" href="graph.less">
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="https://cdn.bootcss.com/less.js/2.7.3/less.min.js"></script>
<script>
let dom_graph = null;
let dom_psn_tpl = null;
let dom_cpl_tpl = null;
let vl_tpl = null;
let hl_tpl = null;
$(document).ready(function(){
    setTimeout("onload()",1000);
});
function onload() {
    $.ajax({
        url:'graph.json', 
        cache:false, 
        dataType:'json',
        async: true,
        success:function(data){
            dom_graph = $('#graph');
            dom_psn_tpl = $('#template > .person');
            dom_psn_tpl.outlineOffset = parseInt(dom_psn_tpl.css('marginLeft'))-parseInt(dom_psn_tpl.css('outlineOffset'))-parseInt(dom_psn_tpl.css('outlineWidth'));
            vl_tpl = $('#template > .vline');
            hl_tpl = $('#template > .hline');
            dom_cpl_tpl = $('#template > .couple-box');
            for (first_name in data) {
                drawFamily(data[first_name])
            }
        },
        error:function(){
            alert('加载图谱数据出错');
        }
    });
}
function drawFamily(family) { // 绘制一个家族的图
    let level_list = family.level_list;
    let person_map = family.person_map;
    createPerson(level_list, person_map);
    adjustAllLevels(person_map);
    drawLevelLines(person_map);
    drawCoupleBoxes(person_map);
}
function createPerson(level_list, person_map) { // 将人物添加到页面
    for (let lvl of level_list) {
        let lvl_number = lvl.level_number;
        let dom_lvl = $('#level-'+lvl_number);
        for (let name of lvl.person_list) {
            let psn = person_map[name];
            let dom_psn = dom_psn_tpl.clone().attr('person', name);
            dom_psn.find('.name').text(name);
            fillPsnScript(dom_psn, psn);
            calChildrenOrder(psn, person_map);
            if (psn.info.dead)
                dom_psn.addClass('dead');
            // 将此人dom添加到页面
            dom_lvl.append(dom_psn);
        }
    }
}
function fillPsnScript(dom_psn, psn) { // 填写某个人的上下标
    let dom_psn_super_s = dom_psn.find('.super-script');
    let psn_super_s_is_empty = false;
    let dom_psn_sub_s = dom_psn.find('.sub-script');
    let psn_sub_s_is_empty = false;
    let avai_list = []; // 可用的名号
    // 长子次子名号
    if (psn.master && psn.master.generation>1) {
        if (psn.children_idx) {
            let idx_str = '';
            if (psn.children_idx==1) idx_str = '长';
            if (psn.children_idx==2) idx_str = '次';
            if (psn.children_idx==3) idx_str = '三';
            if (psn.children_idx==4) idx_str = '四';
            let txt = idx_str+(psn.info.gender=='男'?'子':'女');
            avai_list.push(txt);
        }
    }
    if (psn.name=='贾蔷')
        avai_list.push('养育')
    // 爵位官位名号
    let nobility = psn.social_position? psn.social_position.nobility_title : '';
    let official = psn.social_position? psn.social_position.official_title : '';
    if (nobility.length>0 && nobility.length<=3) {
        avai_list.push(nobility);
    } else if (official.length>0 && official.length<=3) {
        avai_list.push(official);
    }
    // 妻妾排行名号
    if (psn.wives_idx && psn.master && psn.master.generation>2) {
        let txt = psn.wives_idx==1?'大太太':'姨太太';
        avai_list.push(txt);
    }
    // 尊称名号
    for (let i=1; i<=4; ++i) {
        let txt = psn.info['title_'+i];
        if (txt.length>0 && txt.length<=3) {
            avai_list.push(txt);
        }
    }
    // 诨名
    for (let i=1; i<=4; ++i) {
        let txt = psn.info['nick_'+i];
        if (txt.length>0 && txt.length<=3) {
            avai_list.push(txt);
        }
    }
    // 所有可用名号里前两位就是上标下标
    if (avai_list.length>0) {
        let txt = avai_list[0];
        dom_psn_super_s.text(txt);
        if (txt.length>2)
            dom_psn_super_s.addClass('char'+txt.length);
    }
    if (avai_list.length>1) {
        let txt = avai_list[1];
        dom_psn_sub_s.text(txt);
        if (txt.length>2)
            dom_psn_sub_s.addClass('char'+txt.length);
    } else {
        dom_psn_sub_s.text('');
    }
    // 如果上标下标都是空的，则隐藏这块空间
    if (avai_list.length==0)
        dom_psn.find('.script-box').remove();
}
function calChildrenOrder(psn, person_map) { // 为这个人计算其长子次子长女次女这些信息
    if (psn.info.gender=='女')
        return;
    // 找出此人跟所有妻妾的孩子
    let children = [];
    for (let name of psn.child_list) {
        children.push(person_map[name]);
    }
    let wives_idx = 1;
    for (let wife_name of psn.wife_list) {
        let wife = person_map[wife_name];
        for (let name of wife.child_list) {
            children.push(person_map[name]);
        }
        // 顺便把妻子的排行记录下
        wife.wives_idx = wives_idx;
        ++wives_idx;
    }
    // 按照年龄对孩子们排序
    children.sort(function(a,b){
        if (a.info.sort_age>b.info.sort_age)
            return -1;
        if (a.info.sort_age<b.info.sort_age)
            return 1;
        return 0;
    });
    // 分男女对孩子计算序号
    let boy_idx = 1;
    let girl_idx = 1;
    for (let psn of children) {
        if (psn.info.gender=='男') {
            if (psn.info.name=='贾蔷')
                continue;
            psn.children_idx = boy_idx;
            ++boy_idx;
        } else {
            psn.children_idx = girl_idx;
            ++girl_idx;
        }
    }
}
function adjustAllLevels(person_map) { // 根据代际关系大致调整人物位置
    for (let n=0; n<100; ++n) { // 100是防止死循环
        let graph_has_adjusted = false;
        for (let lvl_nbr=1; lvl_nbr<5; ++lvl_nbr) {
            for (let i=0; i<100; ++i) { // 100是防止死循环
                let lvl_has_adjusted = adjustNeighborLevels(lvl_nbr, person_map);
                if (lvl_has_adjusted)
                    graph_has_adjusted = true;
                if (!lvl_has_adjusted)
                    break;
            }
        }
        if (!graph_has_adjusted)
            break;
    }
}
function adjustNeighborLevels(lvl_nbr, person_map) { // 大致调整相邻两个代际的人物位置
    let dom_lvl_psns = $('#level-'+lvl_nbr+' > [name=person]');
    let dom_nlvl_psns = $('#level-'+(lvl_nbr+1)+' > [name=person]');
    let nlvl_psns_names = [];
    for (let i=0; i<dom_nlvl_psns.length; ++i)
        nlvl_psns_names.push(dom_nlvl_psns.eq(i).attr('person'));
    for (let idx=0; idx<dom_lvl_psns.length; ++idx) {
        // 本层中每个人都检查下位置
        let dom_psn = dom_lvl_psns.eq(idx);
        let name = dom_psn.attr('person');
        if (typeof(name)=='undefined') // 是空白(class=fake)
            continue;
        let psn = person_map[name];
        let children_names = getChildrenNames(psn, person_map);
        if (children_names.length==0) // 没有孩子就不用调整了
            continue;
        let child_min_dom_idx = 999;
        let child_max_dom_idx = -1;
        for (let child_name of children_names) {
            let child_dom_idx = nlvl_psns_names.indexOf(child_name);
            if (child_dom_idx<child_min_dom_idx)
                child_min_dom_idx = child_dom_idx;
            if (child_dom_idx>child_max_dom_idx)
                child_max_dom_idx = child_dom_idx;
        }
        if (idx>child_max_dom_idx) {
            // 如果上层元素在所有下层孩子元素右侧，则下层元素前面要补充空白
            let fake_psn_cnt = idx - child_max_dom_idx;
            //console.log(name, '在孩子右侧，补充空白数量为：',fake_psn_cnt, idx, child_max_dom_idx);
            for (let i=0; i<fake_psn_cnt; ++i) {
                let dom_fake = dom_psn_tpl.clone().addClass('fake');
                dom_fake.insertBefore(dom_nlvl_psns.eq(child_min_dom_idx));
            }
            return 1;
        } else if (idx<child_min_dom_idx) {
            // 如果上层元素在所有下层孩子元素左侧，则上层元素前面要补充空白
            let fake_psn_cnt = child_min_dom_idx - idx;
            //console.log(name, '在孩子左侧，补充空白数量为：',fake_psn_cnt, idx, child_min_dom_idx);
            for (let i=0; i<fake_psn_cnt; ++i) {
                let dom_fake = dom_psn_tpl.clone().addClass('fake');
                dom_fake.insertBefore(dom_lvl_psns.eq(idx));
            }
            return 1;
        }
    }
    return 0;
}
function getChildrenNames(psn, person_map) { // 找出此人的孩子
    let children = [];
    if (psn.info.gender=='男') {
        // 如果是男人，就找出此人跟所有妻妾的孩子
        for (let name of psn.child_list) {
            children.push(name);
        }
        let wives_idx = 1;
        for (let wife_name of psn.wife_list) {
            let wife = person_map[wife_name];
            for (let name of wife.child_list) {
                children.push(name);
            }
        }
    } else {
        // 如果是女人，就找亲生孩子就可以了
        for (let name of psn.child_list) {
           children.push(name);
        }
    }
    return children;
}
function drawLevelLines(person_map) { // 为代际之间的关联关系画线
    let dom_psn_list = $(document).find('.person');
    for (let i=0; i<dom_psn_list.length; ++i) {
        let dom_psn = dom_psn_list.eq(i);
        let name = dom_psn.attr('person');
        if (typeof(name)=='undefined' || name=='贾公')
            continue;
        let psn_pos = dom_psn.position();
        let psn_w = dom_psn.outerWidth(true);
        let psn_h = dom_psn.outerHeight(true);
        let start_point = [psn_pos.left+psn_w/2, psn_pos.top+psn_h-dom_psn_tpl.outlineOffset];
        let psn = person_map[name];
        let end_point_list = [];
        for (let child_name of psn.child_list) {
            let dom_cpsn = dom_psn_list.filter('[person='+child_name+']');
            let cpsn_pos = dom_cpsn.position();
            let cpsn_w = dom_cpsn.outerWidth(true);
            let cpsn_h = dom_cpsn.outerHeight(true);
            end_point_list.push([cpsn_pos.left+cpsn_w/2, cpsn_pos.top+dom_psn_tpl.outlineOffset]);
        }
        drawBranchLine(start_point, end_point_list);
    }
}
function drawBranchLine(start, end_list) { // 画分叉线
    let min_end_x = 99999999;
    let max_end_x = -1;
    let min_end_y = 99999999; // 结束点里纵坐标最小值
    for (let p of end_list) {
        if (p[0] < min_end_x)
            min_end_x = p[0];
        if (p[0] > max_end_x)
            max_end_x = p[0];
        if (p[1] < min_end_y)
            min_end_y = p[1];
    }
    if (start[0] < min_end_x)
        min_end_x = start[0];
    if (start[0] > max_end_x)
        max_end_x = start[0];
    let turn_y = (start[1]+min_end_y)/2; // 分叉点的纵坐标
    drawVLine(start, [start[0],turn_y]);
    drawHLine([min_end_x,turn_y], [max_end_x,turn_y]);
    for (let p of end_list) {
        drawVLine([p[0],turn_y], p);
    }
}
function drawVLine(start, end) { // 画一根竖线
    let l = vl_tpl.clone();
    l.css('left', start[0]).css('top', start[1]);
    l.css('height', end[1]-start[1]);
    dom_graph.append(l);
}
function drawHLine(start, end) { // 画一根横线
    let l = hl_tpl.clone();
    l.css('left', start[0]).css('top', start[1]);
    l.css('width', end[0]-start[0]);
    dom_graph.append(l);
}
function drawCoupleBoxes(person_map) { // 画夫妻框
    let dom_psn_list = $(document).find('.person');
    for (let i=0; i<dom_psn_list.length; ++i) {
        let dom_psn = dom_psn_list.eq(i);
        let name = dom_psn.attr('person');
        if (typeof(name)=='undefined' || name=='贾公')
            continue;
        let psn = person_map[name];
        if (psn.info.gender!='男' || psn.wife_list.length==0)
            continue;
        let psn_pos = dom_psn.position();
        let psn_w = dom_psn.outerWidth(true);
        let psn_h = dom_psn.outerHeight(true);
        let last_wife_name = psn.wife_list[psn.wife_list.length-1];
        let last_wife = person_map[last_wife_name];
        let dom_wife = dom_psn_list.filter('[person='+last_wife_name+']');
        let wife_pos = dom_wife.position();
        let outlineWidth = parseInt(dom_psn.css('outlineWidth'));
        let dom_cpl_box = dom_cpl_tpl.clone();
        dom_cpl_box.css('left', psn_pos.left+outlineWidth)
            .css('top', psn_pos.top+outlineWidth);
        dom_cpl_box.css('width', wife_pos.left-psn_pos.left+psn_w-outlineWidth*2)
            .css('height',psn_h-outlineWidth*2);
        dom_graph.append(dom_cpl_box);
    }
}
</script>
</head>
<body lang=cn>
    <div class=hide id=template>
        <div class=person name=person>
            <div class=name>　</div>
            <div class=script-box>
                <div class=super-script>　</div>
                <div class=sub-script>　</div>
            </div>
        </div>
        <div class=couple-box></div>
        <div class=hline></div>
        <div class=vline></div>
    </div>
    <div class=graph id="graph">
        <div class=hide id=level-0></div>
        <div class=level id=level-1></div>
        <div class=space-between-level></div>
        <div class=level id=level-2></div>
        <div class=space-between-level></div>
        <div class=level id=level-3></div>
        <div class=space-between-level></div>
        <div class=level id=level-4></div>
        <div class=space-between-level></div>
        <div class=level id=level-5></div>
    </div>
</body>
</html>