<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta http-equiv="refresh" content="2000">
<link rel="stylesheet/less" type="text/css" href="graph.less">
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="https://cdn.bootcss.com/less.js/2.7.3/less.min.js"></script>
<script>
less.pageLoadFinished.then(()=>{onload();});
let dom_graph = null;
let dom_psn_tpl = null;
let dom_cpl_tpl = null;
let vl_tpl = null;
let hl_tpl = null;
function onload() {
    $.ajax({
        url:'graph.json', 
        cache:false, 
        dataType:'json',
        async: true,
        success:function(data){
            dom_graph = $('#graph');
            dom_psn_tpl = $('#template > .person');
            dom_psn_tpl.outlineOffset = parseInt(dom_psn_tpl.css('marginLeft'))-parseInt(dom_psn_tpl.css('outlineOffset'))-parseInt(dom_psn_tpl.css('outlineWidth'));
            vl_tpl = $('#template > .vline');
            hl_tpl = $('#template > .hline');
            dom_cpl_tpl = $('#template > .couple-box');
            for (first_name in data) {
                drawFamily(data[first_name])
            }
        },
        error:function(){
            alert('加载图谱数据出错');
        }
    });
}
function drawFamily(family) { // 绘制一个家族的图
    let level_list = family.level_list;
    let person_map = family.person_map;
    let master_name_list = createDomForAllMaster(level_list, person_map);
    adjustPositionForAllMaster(master_name_list, person_map);
    drawLevelLines(master_name_list, person_map);
    drawCoupleBoxes(master_name_list, person_map);
}
function createDomForAllMaster(level_list, person_map) { // 将主子类型的人物添加到页面，返回所有master的列表
    let master_name_list = [];
    for (let lvl of level_list) {
        let lvl_number = lvl.level_number;
        if (lvl_number<1)
            continue;
        let dom_lvl = dom_graph.find(`[name=level-${lvl_number}]`);
        for (let name of lvl.person_list) {
            master_name_list.push(name);
            let psn = person_map[name];
            let dom_psn = dom_psn_tpl.clone().attr('person', name);
            dom_psn.find('.name').text(name);
            fillMasterScript(dom_psn, psn);
            calChildrenOrder(psn, person_map);
            fillMasterServant(dom_psn, psn, person_map);
            if (psn.info.dead)
                dom_psn.addClass('dead');
            // 将此人dom添加到页面。同时为了将来可以调整位置，在其前面也加入个空白dom
            let dom_space = $('<div class=space-between-person></div>');
            dom_lvl.append(dom_space);
            dom_lvl.append(dom_psn);
            // 将dom记录到person_map中
            person_map[name].dom_psn = dom_psn;
            person_map[name].dom_psn_space = dom_space;
        }
    }
    return master_name_list;
}
function fillMasterScript(dom_psn, psn) { // 填写某个人的上下标
    let dom_psn_super_s = dom_psn.find('.super-script');
    let psn_super_s_is_empty = false;
    let dom_psn_sub_s = dom_psn.find('.sub-script');
    let psn_sub_s_is_empty = false;
    let avai_list = []; // 可用的名号
    let default_scr_len = 3;
    let max_scr_len = avai_list.length>0? 6-avai_list[0].length : default_scr_len;
    // 长子次子名号
    if (psn.master && psn.master.generation>1) {
        if (psn.children_idx) {
            let idx_str = '';
            if (psn.children_idx==1) idx_str = '长';
            if (psn.children_idx==2) idx_str = '次';
            if (psn.children_idx==3) idx_str = '三';
            if (psn.children_idx==4) idx_str = '四';
            let txt = idx_str+(psn.info.gender=='男'?'子':'女');
            avai_list.push(txt);
        }
    }
    if (psn.parent && psn.as_child_type!='亲生')
        avai_list.push('非亲生');
    // 妻妾排行名号
    if (psn.wives_idx && psn.master && psn.master.generation>2) {
        let txt = psn.wives_idx==1?'正室':'偏房';
        avai_list.push(txt);
    }
    /*if (psn.husband && psn.as_wife_type=='续弦')
        avai_list.push('续弦');*/
    // 尊称名号
    default_scr_len = 5;
    max_scr_len = avai_list.length>0? 6-avai_list[0].length : default_scr_len;
    for (let i=1; i<=4; ++i) {
        let txt = psn.info['title_'+i];
        if (txt.length>0 && txt.length<=max_scr_len) {
            avai_list.push(txt);
        }
    }
    // 爵位官位名号
    let nobility = psn.social_position? psn.social_position.nobility_title : '';
    let official = psn.social_position? psn.social_position.official_title : '';
    if (nobility.length>0 && nobility.length<=max_scr_len) {
        avai_list.push(nobility);
    } else if (official.length>0 && official.length<=max_scr_len) {
        avai_list.push(official);
    }
    // 诨名
    max_scr_len = avai_list.length>0? 6-avai_list[0].length : default_scr_len;
    for (let i=1; i<=4; ++i) {
        let txt = psn.info['nick_'+i];
        if (txt.length>0 && txt.length<=max_scr_len) {
            avai_list.push(txt);
        }
    }
    // 所有可用名号里前两位就是上标下标
    if (avai_list.length>0) {
        let txt = avai_list[0];
        dom_psn_super_s.text(txt);
        if (txt.length>2)
            dom_psn_super_s.addClass('char'+txt.length);
    }
    if (avai_list.length>1) {
        let txt = avai_list[1];
        dom_psn_sub_s.text(txt);
        if (txt.length>2)
            dom_psn_sub_s.addClass('char'+txt.length);
    } else {
        dom_psn_sub_s.text('');
    }
    // 如果上标下标都是空的，则隐藏这块空间
    if (avai_list.length==0)
        dom_psn.find('.script-box').remove();
}
function calChildrenOrder(psn, person_map) { // 为这个人计算其长子次子长女次女这些信息
    // 找出此人自己的直接连线孩子、其所有妻妾的连线孩子
    let children = [];
    for (let name of psn.child_list) {
        children.push(person_map[name]);
    }
    let wives_idx = 1;
    for (let wife_name of psn.wife_list) {
        let wife = person_map[wife_name];
        for (let name of wife.child_list) {
            children.push(person_map[name]);
        }
        // 顺便把妻子的排行记录下
        wife.wives_idx = wives_idx;
        ++wives_idx;
    }
    // 将孩子保存一份到psn里
    psn.all_child_list = children.map(x => x.name);
    // 女人就不需要对孩子们计算长子次子了，这是男人所有妻妾子女的事情
    if (psn.info.gender=='女')
        return;
    // 按照年龄对孩子们排序
    children.sort(function(a,b){
        if (a.info.sort_age>b.info.sort_age)
            return -1;
        if (a.info.sort_age<b.info.sort_age)
            return 1;
        return 0;
    });
    // 分男女对孩子计算序号
    let boy_idx = 1;
    let girl_idx = 1;
    for (let child of children) {
        if (child.as_child_type!='亲生')
            continue;
        if (child.info.gender=='男') {
            child.children_idx = boy_idx;
            ++boy_idx;
        } else {
            child.children_idx = girl_idx;
            ++girl_idx;
        }
    }
}
function fillMasterServant(dom_psn, psn, person_map) { // 填充这个主子名下的丫鬟小厮仆人
    dom_psn.find('.servant-list').remove();
}
function adjustPositionForAllMaster(master_name_list, person_map) { // 调整所有人物的位置（通过调整人物dom左侧的空白div的宽度）
    for (let n=0; n<100; ++n) {
        // 100是防止死循环，即最多进行这么多次的调整
        // 每次都是遍历所有人物，对人物位置进行检查。
        // 如果需要调整，则调整。本次调整结束，并进行下一次调整。
        // 如果遍历所有人物过程中没有发生任何调整，则认为全部调整完毕，函数结束。
        for (let name of master_name_list) {
            if (person_map[name].all_child_list.length==0)
                continue;
            if (adjustPositionForOneMaster(name, person_map)>0)
                break;
        }
    }
}
function adjustPositionForOneMaster(name, person_map) { // 检查该人物跟其孩子的位置，并进行调整
    // 返回值： 0无任何调整，1调整了本人位置，2调整了孩子的位置
    let psn = person_map[name];
    let left = psn.dom_psn.position().left;
    let width = psn.dom_psn.width();
    let right = left+width;
    let first_child = person_map[ psn.all_child_list[0] ];
    let first_child_dom = first_child.dom_psn;
    let last_child = person_map[ psn.all_child_list[psn.all_child_list.length-1] ];
    let last_child_dom = last_child.dom_psn;
    let child_left_min = first_child_dom.position().left;
    let child_right_max = last_child_dom.position().left+last_child_dom.width();
    let child_width = child_right_max - child_left_min;
    if (left < child_left_min) {
        // 如果当前元素在首个孩子元素左侧，则自己前面要补充空白
        let dont_need = 0; // 但有种特殊情况是不需要调整位置的（比如：林如海和贾敏夫妇）
        if (psn.child_list.length==0 // 没有直接连线孩子
            && psn.all_child_list.length==1 // 总共只有一个孩子
            && left>first_child.dom_psn_space.position().left //当前元素处于首个孩子元素左侧的空白的上方
        ) {
            dont_need = 1;
        }
        if (dont_need)
            return 0;
        //console.log(`${name} 在首个孩子 ${first_child.name} 左侧，自己左边补充空白：${child_left_min-left}`);
        psn.dom_psn_space.width( psn.dom_psn_space.width()+(child_left_min-left) );
        return 1;
    } else if (right > child_right_max) {
        // 如果当前元素在末尾孩子元素右侧，则末尾孩子元素前面要补充空白
        //console.log(`${name} 在末尾孩子 ${last_child.name} 右侧，末尾孩子左边补充空白：${right-child_right_max}`);
        let last_child_dom_space = person_map[ psn.all_child_list[psn.all_child_list.length-1] ].dom_psn_space;
        last_child_dom_space.width( last_child_dom_space.width()+(right-child_right_max) );
        return 2;
    }
    return 0;
}
function getChildrenNames(psn, person_map) { // 找出此人的孩子
    let children = [];
    if (psn.info.gender=='男') {
        // 如果是男人，就找出此人跟所有妻妾的孩子
        for (let name of psn.child_list) {
            children.push(name);
        }
        for (let wife_name of psn.wife_list) {
            let wife = person_map[wife_name];
            for (let name of wife.child_list) {
                children.push(name);
            }
        }
    } else {
        // 如果是女人，就找亲生孩子就可以了
        for (let name of psn.child_list) {
           children.push(name);
        }
    }
    return children;
}
function drawLevelLines(master_name_list, person_map) { // 为代际之间的关联关系画线
    for (let name of master_name_list) {
        let psn = person_map[name];
        if (psn.child_list.length==0)
            continue;
        let dom_psn = psn.dom_psn;
        let psn_pos = dom_psn.position();
        let psn_w = dom_psn.outerWidth();
        let psn_h = dom_psn.outerHeight();
        let start_point = [psn_pos.left+psn_w/2, psn_pos.top+psn_h-dom_psn_tpl.outlineOffset];
        let end_point_list = [];
        for (let child_name of psn.child_list) {
            let dom_cpsn = person_map[child_name].dom_psn;
            let cpsn_pos = dom_cpsn.position();
            let cpsn_w = dom_cpsn.outerWidth(true);
            let cpsn_h = dom_cpsn.outerHeight(true);
            end_point_list.push([cpsn_pos.left+cpsn_w/2, cpsn_pos.top+dom_psn_tpl.outlineOffset]);
        }
        drawBranchLine(start_point, end_point_list);
    }
}
function drawBranchLine(start, end_list) { // 画分叉线
    let min_end_x = 999999;
    let max_end_x = -1;
    let min_end_y = 999999; // 结束点里纵坐标最小值
    for (let p of end_list) {
        if (p[0] < min_end_x)
            min_end_x = p[0];
        if (p[0] > max_end_x)
            max_end_x = p[0];
        if (p[1] < min_end_y)
            min_end_y = p[1];
    }
    if (start[0] < min_end_x)
        min_end_x = start[0];
    if (start[0] > max_end_x)
        max_end_x = start[0];
    let turn_y = (start[1]+min_end_y)/2; // 分叉点的纵坐标
    drawVLine(start, [start[0],turn_y]);
    drawHLine([min_end_x,turn_y], [max_end_x,turn_y]);
    for (let p of end_list) {
        drawVLine([p[0],turn_y], p);
    }
}
function drawVLine(start, end) { // 画一根竖线
    let l = vl_tpl.clone();
    l.css('left', start[0]).css('top', start[1]);
    l.css('height', end[1]-start[1]);
    dom_graph.append(l);
}
function drawHLine(start, end) { // 画一根横线
    let l = hl_tpl.clone();
    l.css('left', start[0]).css('top', start[1]);
    l.css('width', end[0]-start[0]);
    dom_graph.append(l);
}
function drawCoupleBoxes(master_name_list, person_map) { // 画夫妻框
    for (let name of master_name_list) {
        let psn = person_map[name];
        if (psn.info.gender!='男' || psn.wife_list.length==0)
            continue;
        let dom_psn = psn.dom_psn;
        let psn_pos = dom_psn.position();
        //let psn_w = dom_psn.outerWidth(true);
        let psn_h = dom_psn.outerHeight(true);
        let last_wife_name = psn.wife_list[psn.wife_list.length-1];
        let last_wife = person_map[last_wife_name];
        let dom_wife = last_wife.dom_psn;
        let wife_pos = dom_wife.position();
        let border_w = parseInt(dom_psn.css('outlineWidth'))+parseInt(dom_psn.css('borderTopWidth'));
        let dom_cpl_box = dom_cpl_tpl.clone();
        dom_cpl_box.css('left', psn_pos.left-border_w)
            .css('top', psn_pos.top-border_w);
        dom_cpl_box.css('width', wife_pos.left-psn_pos.left+dom_wife.outerWidth()+border_w)
            .css('height',psn_h+border_w);
        dom_graph.append(dom_cpl_box);
    }
}
</script>
</head>
<body lang=cn>
    <div class=gragh-brief>版本：20180224</div>
    <div class=hide id=template>
        <div class=person name=person>
            <div class=master>
                <div class=name>贾宝玉</div>
                <div class=script-box>
                    <div class=super-script>上标</div>
                    <div class=sub-script>下标</div>
                </div>
            </div>
            <div class=servant-list>
                <div class=servant>袭人</div>
            </div>
        </div>
        <div class=couple-box></div>
        <div class=hline></div>
        <div class=vline></div>
    </div>
    <div class=graph id="graph">
        <div class=level name=level-1></div>
        <div class=space-between-level></div>
        <div class=level name=level-2></div>
        <div class=space-between-level></div>
        <div class=level name=level-3></div>
        <div class=space-between-level></div>
        <div class=level name=level-4></div>
        <div class=space-between-level></div>
        <div class=level name=level-5></div>
    </div>
</body>
</html>